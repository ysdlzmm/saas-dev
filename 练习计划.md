# 任务管理SaaS系统 - Vue3深度技术练习计划

> 这是一个用于深度练习Vue3、TypeScript、Vite、UnoCSS等前端前沿技术的任务管理系统。

## 📋 项目概述

**项目类型**: 任务管理/项目管理SaaS系统  
**复杂度**: 纯前端 + Mock数据  
**技术重点**: Vue3高级特性（Composition API + 响应式系统 + 组件设计）

## 🛠 技术栈

- **Vue 3.4+** (Composition API + `<script setup lang="ts">`)
- **TypeScript 5.3+** (严格模式)
- **Vite 5.0+** (构建工具)
- **UnoCSS** (原子化CSS)
- **Pinia** (状态管理)
- **Vue Router 4** (路由管理)
- **VueUse** (组合式工具库)

## 🎯 核心功能模块

1. **项目仪表盘** - 统计卡片、数据可视化
2. **看板视图** - 拖拽排序、多列任务
3. **列表视图** - 表格展示、筛选排序
4. **任务详情** - 抽屉式详情、子任务管理
5. **设置中心** - 主题切换、个人偏好

## 📚 Vue3深度技术点

- ✅ 响应式系统（ref/reactive/computed/watch/watchEffect）
- ✅ 自定义Composables（逻辑复用）
- ✅ 依赖注入（provide/inject）
- ✅ 组件通信（props/emit/expose/teleport）
- ✅ 指令系统（自定义指令）
- ✅ 插件开发（Vue插件）
- ✅ 性能优化（computed缓存、虚拟滚动）
- ✅ TypeScript泛型约束

---

## 🚀 分阶段练习计划

### 阶段一：工程化基础与配置

> **重点**: Vite + TypeScript + UnoCSS  
> **目标**: 掌握现代前端工程化的基础配置和优化

#### TODO-1.1: Vite项目初始化与TypeScript严格模式配置

**练习目标:**
- [ ] 使用 Vite 创建 Vue3+TS 项目脚手架
- [ ] 配置 `tsconfig.json` 严格模式（`strict: true`）
- [ ] 配置路径别名（`@/` 指向 `src`）
- [ ] 配置环境变量管理（`.env.development` / `.env.production`）

**技术深度分析:**
- **TypeScript严格模式**: 强制类型检查，培养类型思维，避免 `any` 滥用
- **路径别名**: 提升代码可维护性，需要理解模块解析机制（`resolve.alias`）
- **环境变量隔离**: SaaS多环境部署的基础（`import.meta.env`）
- **Vite配置**: 理解 `defineConfig` 的配置选项和类型提示

**验收标准:**
- TypeScript无编译错误
- 路径别名可正常导入（`import { foo } from '@/bar'`）
- 环境变量可在代码中访问且类型安全

---

#### TODO-1.2: UnoCSS原子化CSS配置与设计系统

**练习目标:**
- [ ] 配置 UnoCSS 规则和主题变量
- [ ] 建立设计Token系统（颜色、间距、圆角等）
- [ ] 实现暗黑模式切换
- [ ] 使用 `@apply` 指令封装常用样式组合

**技术深度分析:**
- **原子化CSS原理**: 减少CSS体积，按需生成，避免无用样式
- **设计Token**: 统一视觉语言，SaaS产品化的基础（CSS变量 + UnoCSS配置）
- **主题切换**: CSS变量 + 类名策略（`dark:` 前缀）
- **UnoCSS vs Tailwind**: 编译时 vs 运行时，性能差异对比

**核心配置示例:**
```typescript
// uno.config.ts
export default defineConfig({
  theme: {
    colors: {
      primary: 'var(--primary-color)',
      // ... 更多Token
    }
  },
  shortcuts: {
    'btn-base': 'px-4 py-2 rounded transition',
  }
})
```

**验收标准:**
- 暗黑模式切换流畅无闪烁
- 所有组件使用原子化CSS类名
- 设计Token在全局统一生效

---

#### TODO-1.3: Vite插件开发与构建优化

**练习目标:**
- [ ] 开发自定义Vite插件（如：自动导入组件）
- [ ] 配置构建优化（代码分割、压缩、Tree Shaking）
- [ ] 实现模块预加载和懒加载策略
- [ ] 配置PWA能力（可选）

**技术深度分析:**
- **Vite钩子函数**: 理解Rollup构建流程（`transform`、`buildStart`、`generateBundle`）
- **代码分割策略**: 
  - `manualChunks` 分离vendor代码
  - 动态导入（`import()`）实现路由懒加载
- **Tree Shaking**: ES Module的静态分析优势
- **资源压缩**: terser（JS）、cssnano（CSS）的配置

**插件开发示例:**
```typescript
// 自定义插件：自动导入组件
function autoImportComponents() {
  return {
    name: 'auto-import-components',
    transform(code, id) {
      // 转换逻辑
    }
  }
}
```

**验收标准:**
- 构建产物分析（rollup-plugin-visualizer）
- 首屏加载时间 < 2s
- 路由切换流畅无卡顿

---

### 阶段二：Vue3响应式系统深度实践

> **核心重点**: 响应式原理 + TypeScript类型约束  
> **目标**: 深入理解Vue3响应式系统，掌握响应式API的最佳实践

#### TODO-2.1: 响应式基础与类型约束

**练习目标:**
- [ ] 实现任务数据的 `reactive` 响应式对象
- [ ] 使用 `ref` 包装基础类型和 `computed` 派生数据
- [ ] 区分 `ref` vs `reactive` 的使用场景
- [ ] 为响应式数据编写严格的TS类型定义

**技术深度分析:**
- **响应式原理**: Vue3使用 `Proxy` vs Vue2的 `Object.defineProperty`
- **ref解包机制**: 在模板中自动解包，在JS中需要 `.value`
- **reactive陷阱**: 
  - 解构会丢失响应性
  - 不能替换整个对象（`obj = {}`）
- **泛型约束**: `Reactive<T>` 和 `Ref<T>` 的类型推导

**代码示例:**
```typescript
interface Task {
  id: string
  title: string
  status: 'todo' | 'done'
}

// ❌ 错误：解构丢失响应性
const { status } = reactive(task)

// ✅ 正确：使用 toRefs
const { status } = toRefs(reactive(task))

// ✅ 正确：ref包装基础类型
const taskCount = ref(0)
```

**验收标准:**
- 所有响应式数据都有明确的类型定义
- 避免解构reactive对象的陷阱
- TypeScript无类型错误

---

#### TODO-2.2: Computed缓存机制与Watcher

**练习目标:**
- [ ] 使用 `computed` 计算任务统计数据（完成率、逾期数）
- [ ] 实现 `watch` 监听任务变化并持久化到localStorage
- [ ] 使用 `watchEffect` 自动追踪依赖（如自动保存草稿）
- [ ] 理解 `computed` 的缓存失效和lazy求值

**技术深度分析:**
- **computed缓存**: 
  - 只有依赖变化才重新计算
  - 多次访问返回缓存结果
  - 与方法调用的性能差异
- **watch vs watchEffect**:
  - `watch`: 明确指定监听源，可访问新旧值
  - `watchEffect`: 自动追踪依赖，立即执行
- **flush时机**:
  - `pre`: 组件更新前调用
  - `post`: 组件更新后调用
  - `sync`: 同步执行

**性能对比示例:**
```typescript
// ❌ 低效：每次调用都重新计算
function getCompletedRate() {
  return tasks.filter(t => t.done).length / tasks.length
}

// ✅ 高效：computed缓存结果
const completedRate = computed(() => 
  tasks.filter(t => t.done).length / tasks.length
)
```

**验收标准:**
- 使用DevTools监控computed的缓存命中率
- watch监听不触发无谓的重复执行
- watchEffect正确清理副作用（`onWatcherCleanup`）

---

#### TODO-2.3: 响应式工具函数封装

**练习目标:**
- [ ] 封装 `useStorage` 实现响应式localStorage
- [ ] 封装 `useDebounceFn` 防抖函数
- [ ] 封装 `useThrottleFn` 节流函数
- [ ] 封装 `useInterval` 定时器管理

**技术深度分析:**
- **响应式与副作用**: 
  - 使用 `watchEffect` 监听ref变化并同步到localStorage
  - 返回的ref是双向绑定的
- **内存泄漏防范**:
  - 组件卸载时清理定时器（`onUnmounted`）
  - 事件监听器的移除
- **副作用清理**: 
  - `watchEffect` 返回清理函数
  - `onWatcherCleanup` (Vue 3.5+)

**useStorage实现示例:**
```typescript
function useStorage<T>(key: string, defaultValue: T) {
  const stored = ref<T>(defaultValue)
  
  // 初始化读取
  const saved = localStorage.getItem(key)
  if (saved) stored.value = JSON.parse(saved)
  
  // 同步到localStorage
  watchEffect(() => {
    localStorage.setItem(key, JSON.stringify(stored.value))
  })
  
  return stored
}
```

**验收标准:**
- 防抖/节流函数可复用
- 定时器正确清理，无内存泄漏
- useStorage双向绑定正常工作

---

### 阶段三：Composables设计模式

> **核心重点**: 逻辑复用 + 测试能力  
> **目标**: 掌握Vue3的组合式API设计哲学，编写可测试的复用逻辑

#### TODO-3.1: 领域逻辑抽离 - useTaskManager

**练习目标:**
- [ ] 抽离任务CRUD逻辑到Composable
- [ ] 实现任务的增删改查基础操作
- [ ] 封装任务筛选、排序、搜索逻辑
- [ ] 编写单元测试验证Composable

**技术深度分析:**
- **Composable vs Mixins vs Hooks**:
  - Mixins: 命名冲突、来源不明
  - Composables: 明确的输入输出，支持TypeScript
- **单一职责**: 每个Composable只做一件事
- **可测试性**: 
  - 不依赖组件生命周期
  - 纯函数逻辑易于测试
- **泛型约束**: 支持不同类型的数据

**useTaskManager示例:**
```typescript
function useTaskManager() {
  const tasks = ref<Task[]>([])
  
  const addTask = (task: Omit<Task, 'id'>) => {
    tasks.value.push({
      ...task,
      id: generateId()
    })
  }
  
  const removeTask = (id: string) => {
    const index = tasks.value.findIndex(t => t.id === id)
    if (index > -1) tasks.value.splice(index, 1)
  }
  
  const updateTask = (id: string, updates: Partial<Task>) => {
    const task = tasks.value.find(t => t.id === id)
    if (task) Object.assign(task, updates)
  }
  
  return {
    tasks,
    addTask,
    removeTask,
    updateTask
  }
}
```

**验收标准:**
- Composable可在多个组件中复用
- 编写单元测试覆盖主要逻辑
- TypeScript类型推导正确

---

#### TODO-3.2: 跨组件通信 - useTaskSelection

**练习目标:**
- [ ] 实现多选任务的共享状态
- [ ] 提供 `toggleSelectAll` / `clearSelection` 方法
- [ ] 使用 `provide/inject` 跨级共享
- [ ] 配合 `computed` 计算选中任务数量

**技术深度分析:**
- **provide/inject的响应性**:
  - 使用 `Symbol` 作为key避免命名冲突
  - 提供的ref保持响应性
- **跨组件状态测试**:
  - 使用 `@vue/test-utils` 的 `provide` 方法
- **单向数据流**: 
  - 子组件通过方法修改状态
  - 父组件通过computed监听变化

**provide/inject示例:**
```typescript
// 父组件
const selectedTasks = ref<Set<string>>(new Set())
provide(selectionKey, {
  selectedTasks,
  toggle: (id: string) => {
    if (selectedTasks.value.has(id)) {
      selectedTasks.value.delete(id)
    } else {
      selectedTasks.value.add(id)
    }
  }
})

// 子组件
const { selectedTasks, toggle } = inject(selectionKey)!
```

**验收标准:**
- 跨组件状态同步正常
- provide/inject类型安全
- 避免inject默认值的陷阱

---

#### TODO-3.3: 异步状态管理 - useAsyncTask

**练习目标:**
- [ ] 封装异步操作的 loading/error/success 状态
- [ ] 实现自动重试和超时处理
- [ ] 支持请求取消（AbortController）
- [ ] 缓存策略（避免重复请求）

**技术深度分析:**
- **异步状态机**: idle → pending → success/error
- **AbortController**: 
  - 与Vue组件生命周期的集成
  - 组件卸载时取消请求
- **请求去重**: 
  - 使用Map缓存pending请求
  - 相同请求返回同一个Promise
- **错误边界**: 
  - 全局错误处理（app.config.errorHandler）
  - 局部错误恢复

**useAsyncTask示例:**
```typescript
function useAsyncTask<T>() {
  const state = ref<'idle' | 'pending' | 'success' | 'error'>('idle')
  const data = ref<T | null>(null)
  const error = ref<Error | null>(null)
  
  const execute = async (fn: () => Promise<T>) => {
    state.value = 'pending'
    try {
      data.value = await fn()
      state.value = 'success'
    } catch (e) {
      error.value = e as Error
      state.value = 'error'
    }
  }
  
  return { state, data, error, execute }
}
```

**验收标准:**
- 异步状态转换正确
- 请求可正常取消
- 错误处理和重试机制工作正常

---

### 阶段四：组件架构与通信

> **重点**: 组件设计 + Props/Emit/插槽  
> **目标**: 掌握Vue3组件的最佳实践和设计模式

#### TODO-4.1: 组件Props严格类型与默认值

**练习目标:**
- [ ] 定义任务卡片组件的 Props 接口
- [ ] 使用 `withDefaults` 设置默认值
- [ ] 使用 PropTypes 运行时验证（可选）
- [ ] 区分 required/optional 属性

**技术深度分析:**
- **类型安全**: TypeScript编译时 + 运行时验证
- **对象/数组默认值**: 
  - 避免每次创建新实例（函数返回默认值）
- **函数类型Props**: 
  - 正确的函数签名写法
- **Prop验证**: 
  - 自定义validator函数
  - 异步验证场景

**Props定义示例:**
```typescript
interface TaskCardProps {
  task: Task
  onEdit?: (id: string) => void
  onDelete?: (id: string) => void
  showActions?: boolean
}

const props = withDefaults(defineProps<TaskCardProps>(), {
  showActions: true,
  onEdit: () => {}, // ❌ 错误：每个组件共享同一个函数
  onEdit: (id) => console.log('edit', id) // ✅ 正确
})
```

**验收标准:**
- 所有Props都有类型定义
- 默认值正确设置
- 无Prop类型警告

---

#### TODO-4.2: 组件Emit与事件总线

**练习目标:**
- [ ] 定义组件 emits 类型声明
- [ ] 实现任务的点击/删除/编辑事件
- [ ] 使用mitt库实现兄弟组件通信（可选）
- [ ] 理解单向数据流的约束

**技术深度分析:**
- **emits声明**: 
  - Vue3的显式声明要求
  - 帮助IDE自动补全
- **事件命名规范**: 
  - kebab-case（HTML）vs camelCase（JS）
  - 推荐统一使用kebab-case
- **事件修饰符**: 
  - `.stop` / `.prevent` / `.once`
  - 自定义修饰符
- **事件总线场景**: 
  - 何时使用 mitt vs 状态管理

**emits声明示例:**
```typescript
const emit = defineEmits<{
  edit: [id: string]
  delete: [id: string]
  'update:modelValue': [value: string]
}>()

// 使用
emit('edit', task.id)
```

**验收标准:**
- emits类型推导正确
- 事件正常触发和监听
- 无事件警告

---

#### TODO-4.3: 插槽与内容分发

**练习目标:**
- [ ] 设计任务卡片的具名插槽（头部/操作/扩展）
- [ ] 实现作用域插槽传递任务数据
- [ ] 使用动态插槽名
- [ ] 理解 `$slots` 和 `$children` 的变化

**技术深度分析:**
- **插槽类型**: 
  - 匿名插槽、具名插槽、作用域插槽
- **插槽的惰性渲染**: 
  - 只有插槽有内容时才渲染
  - 性能优化点
- **v-slot解构**: 
  - `v-slot="{ row }"` 的语法糖
- **$slots的变化**: 
  - Vue3中是函数形式
  - `$children` 已移除

**作用域插槽示例:**
```vue
<!-- 父组件 -->
<TaskCard>
  <template #actions="{ task, canEdit }">
    <button v-if="canEdit" @click="edit(task.id)">编辑</button>
  </template>
</TaskCard>

<!-- 子组件 -->
<slot name="actions" :task="task" :canEdit="canEdit(task)" />
```

**验收标准:**
- 插槽内容正确渲染
- 作用域插槽数据传递正常
- 支持动态插槽名

---

#### TODO-4.4: Teleport与Suspense

**练习目标:**
- [ ] 使用 Teleport 实现全局模态框
- [ ] 使用 Suspense 处理异步组件加载
- [ ] 实现骨架屏和加载状态
- [ ] 理解异步组件的 `defineAsyncComponent`

**技术深度分析:**
- **Teleport原理**: 
  - 将组件渲染到DOM的指定位置
  - `to` 属性支持选择器
- **Suspense实验性**: 
  - 未来可能变化
  - 备选方案：手动管理loading状态
- **异步组件**: 
  - 加载/超时/延迟/错误组件
  - 与路由懒加载的配合

**Teleport示例:**
```vue
<Teleport to="body">
  <div class="modal-overlay">
    <div class="modal-content">
      <slot />
    </div>
  </div>
</Teleport>
```

**异步组件示例:**
```typescript
const TaskDetail = defineAsyncComponent({
  loader: () => import('./TaskDetail.vue'),
  loadingComponent: LoadingSpinner,
  errorComponent: ErrorDisplay,
  delay: 200,
  timeout: 3000
})
```

**验收标准:**
- 模态框正确渲染到body
- 异步组件加载正常
- 超时和错误处理正确

---

### 阶段五：状态管理与路由

> **重点**: Pinia + Vue Router  
> **目标**: 掌握Vue3官方推荐的状态管理和路由方案

#### TODO-5.1: Pinia Store设计与模块化

**练习目标:**
- [ ] 设计任务Store（actions/getters/state）
- [ ] 实现用户Store（登录/权限）
- [ ] 使用 `store.$patch` 批量更新
- [ ] 实现Store的持久化插件

**技术深度分析:**
- **Pinia vs Vuex4**: 
  - 去除mutations，直接在actions修改state
  - 完整的TypeScript支持
  - 更简洁的API
- **Setup Store**: 
  - 使用 `defineStore` 的函数式写法
  - ref/reactive定义state
- **Store组合**: 
  - 多个Store的互相引用
  - 依赖注入模式

**Store示例:**
```typescript
export const useTaskStore = defineStore('tasks', () => {
  const tasks = ref<Task[]>([])
  
  const completedTasks = computed(() => 
    tasks.value.filter(t => t.status === 'done')
  )
  
  const addTask = (task: Omit<Task, 'id'>) => {
    tasks.value.push({ ...task, id: generateId() })
  }
  
  return { tasks, completedTasks, addTask }
})
```

**验收标准:**
- Store状态正常读写
- getters缓存生效
- 持久化插件工作正常

---

#### TODO-5.2: 路由设计与嵌套路由

**练习目标:**
- [ ] 设计路由层级（`/project/:id/tasks`）
- [ ] 实现路由守卫（权限校验）
- [ ] 使用路由元信息（meta）
- [ ] 实现路由过渡动画

**技术深度分析:**
- **History vs Hash模式**: 
  - History需要服务器配置
  - Hash兼容性更好
- **路由懒加载**: 
  - 魔法注释命名chunk
  - `/* webpackChunkName: "task" */`
- **动态路由**: 
  - `addRoute` 动态添加路由
  - 权限路由控制
- **路由元信息**: 
  - 自定义meta字段
  - 类型扩展声明

**路由配置示例:**
```typescript
const routes = [
  {
    path: '/project/:id',
    component: ProjectLayout,
    children: [
      {
        path: 'tasks',
        component: TaskList,
        meta: { requiresAuth: true, title: '任务列表' }
      }
    ]
  }
]
```

**验收标准:**
- 路由跳转正常
- 守卫拦截生效
- 过渡动画流畅

---

#### TODO-5.3: 路由与状态联动

**练习目标:**
- [ ] 实现URL参数同步到状态（筛选条件）
- [ ] 使用 `watch` 监听路由变化
- [ ] 实现路由离开前的保存提示
- [ ] 设计全局加载状态

**技术深度分析:**
- **query参数作为单一数据源**: 
  - 状态从URL读取
  - 状态变化同步到URL
- **路由监听**: 
  - `watch($route)` 或 `onBeforeRouteUpdate`
- **离开守卫**: 
  - `beforeRouteLeave`
  - 结合用户修改状态判断

**URL同步示例:**
```typescript
// 从URL读取筛选条件
const route = useRoute()
const filters = reactive({
  status: route.query.status || 'all',
  keyword: route.query.keyword || ''
})

// 同步到URL
watch(filters, (new) => {
  router.replace({ query: new })
})
```

**验收标准:**
- URL与状态双向同步
- 路由切换不丢失状态
- 离开提示正常触发

---

### 阶段六：性能优化与高级特性

> **重点**: 性能监控 + 优化技巧  
> **目标**: 掌握Vue3性能优化的方法和工具

#### TODO-6.1: 虚拟滚动与大列表渲染

**练习目标:**
- [ ] 使用 `@vueuse/core` 的 `useVirtualList`
- [ ] 实现任务列表的虚拟滚动
- [ ] 优化大数组的响应式性能
- [ ] 实现无限滚动加载

**技术深度分析:**
- **虚拟滚动原理**: 
  - 只渲染可视区域+缓冲区
  - 计算scrollTop和itemHeight
- **Object.freeze**: 
  - 冻结静态数据避免响应式开销
- **大列表优化**: 
  - 分页加载
  - IntersectionObserver实现无限滚动

**虚拟滚动示例:**
```typescript
const { list, containerProps, wrapperProps } = useVirtualList(
  largeList,
  { itemHeight: 50, overscan: 10 }
)
```

**验收标准:**
- 大列表流畅滚动
- 内存占用稳定
- 滚动定位准确

---

#### TODO-6.2: Keep-Alive与组件缓存

**练习目标:**
- [ ] 使用 `<KeepAlive>` 缓存列表页
- [ ] 实现 `activated` / `deactivated` 生命周期
- [ ] 配合 `include` / `exclude` 控制缓存
- [ ] 实现缓存的销毁策略

**技术深度分析:**
- **LRU缓存算法**: 
  - 最近最少使用淘汰策略
  - 默认缓存10个组件
- **缓存陷阱**: 
  - 缓存组件状态未重置
  - 需要监听activated更新数据
- **include匹配**: 
  - 组件name字段
  - 正则表达式和字符串

**KeepAlive示例:**
```vue
<KeepAlive :include="['TaskList', 'ProjectBoard']" :max="10">
  <RouterView />
</KeepAlive>
```

**验收标准:**
- 缓存组件状态保持
- 切换流畅无闪烁
- 缓存正确销毁

---

#### TODO-6.3: 自定义指令与插件开发

**练习目标:**
- [ ] 实现权限控制指令（`v-permission`）
- [ ] 实现无限加载指令（`v-infinite-scroll`）
- [ ] 实现点击外部关闭指令
- [ ] 开发全局Vue插件

**技术深度分析:**
- **指令生命周期**: 
  - `mounted` / `updated` / `unmounted`
  - Vue2的 `bind` / `update` 合并
- **指令参数和修饰符**: 
  - `v-permission:role.admin`
  - 解析modifiers对象
- **插件开发**: 
  - `install` 方法
  - app.use() 注册

**权限指令示例:**
```typescript
const vPermission = {
  mounted(el: HTMLElement, binding: DirectiveBinding) {
    const { value } = binding
    const roles = useUserStore().roles
    
    if (value && !roles.includes(value)) {
      el.parentNode?.removeChild(el)
    }
  }
}
```

**验收标准:**
- 指令正确应用
- 权限控制生效
- 插件全局可用

---

#### TODO-6.4: 性能监控与调试

**练习目标:**
- [ ] 使用 Vue DevTools 分析组件性能
- [ ] 实现性能监控插件（render时间）
- [ ] 使用 Performance API 测量
- [ ] 优化不必要的重渲染

**技术深度分析:**
- **DevTools使用**: 
  - Performance标签
  - 组件渲染次数监控
- **性能测量**: 
  - `performance.mark()` / `performance.measure()`
  - `onRenderTracked` / `onRenderTriggered`
- **重渲染优化**: 
  - `v-once` 静态内容
  - `v-memo` 条件缓存
  - computed缓存利用

**性能监控示例:**
```typescript
app.config.performance = true

onRenderTriggered((e) => {
  console.log('重渲染触发:', e)
})
```

**验收标准:**
- DevTools性能分析正常
- 识别性能瓶颈
- 优化后性能提升明显

---

## 📊 技术点覆盖矩阵

| 阶段 | Vue3响应式 | TypeScript | 组件设计 | 性能优化 | 工程化 | 状态管理 |
| ---- | ---------- | ---------- | -------- | -------- | ------ | -------- |
| 一   | ⚪          | ⚫⚫⚫        | ⚪        | ⚪        | ⚫⚫⚫    | ⚪        |
| 二   | ⚫⚫⚫        | ⚫⚫         | ⚪        | ⚫        | ⚪      | ⚪        |
| 三   | ⚫⚫⚫        | ⚫⚫⚫        | ⚫        | ⚫        | ⚫      | ⚫        |
| 四   | ⚫⚫         | ⚫⚫⚫        | ⚫⚫⚫      | ⚫        | ⚪      | ⚫        |
| 五   | ⚫⚫         | ⚫⚫         | ⚫⚫       | ⚫        | ⚫⚫     | ⚫⚫⚫      |
| 六   | ⚫          | ⚫          | ⚫⚫       | ⚫⚫⚫      | ⚫⚫⚫    | ⚫        |

- ⚫⚫⚫ = 深度练习（核心重点）
- ⚫⚫ = 中等深度（重要涉及）
- ⚫ = 基础涉及（初步了解）
- ⚪ = 不涉及（暂不包含）

---

## 📝 使用指南

### 开始练习

1. **Clone本项目**
   ```bash
   git clone <repo-url>
   cd saas-dev
   ```

2. **选择阶段开始**
   - 建议按顺序从阶段一开始
   - 或根据你的需求跳转到特定阶段

3. **查看具体TODO**
   - 每个TODO包含详细的目标、分析和示例
   - 参考代码示例进行实践

4. **验收标准**
   - 完成后对照验收标准自检
   - 使用DevTools验证功能

### 学习建议

- **理解原理**: 不止会用，更要理解背后的原理
- **动手实践**: 每个TODO都要亲自写代码
- **对比思考**: 对比不同方案的优劣
- **记录笔记**: 记录遇到的问题和解决方案

### 推荐资源

- [Vue3官方文档](https://cn.vuejs.org/)
- [Vite官方文档](https://cn.vitejs.dev/)
- [UnoCSS文档](https://unocss.dev/)
- [VueUse文档](https://vueuse.org/)
- [TypeScript手册](https://www.typescriptlang.org/docs/)

---

## 🎯 学习成果

完成本计划后，你将掌握：

✅ Vue3组合式API的深度应用  
✅ TypeScript在Vue项目中的最佳实践  
✅ Vite工程化配置和优化  
✅ 组件设计和状态管理架构  
✅ 性能优化和调试技巧  
✅ 前端工程化思维和设计模式  

---

## 📄 License

MIT

---

**Happy Coding! 🚀**
